<script>
import {
    defineComponent, getCurrentInstance, ref, computed,
    onBeforeUnmount, watch, onMounted, nextTick
} from 'vue';
import debounce from 'js/lib/debounce';
import MaxLengthText from 'js/components/UI/MaxLengthText';
import prices from 'js/parsers/prices';
import { getPrices } from 'js/services/pricing';
import { getRecommendations } from 'js/services/recommendations';
import translationsHelper from 'js/composable/translationsHelper';
import authorablePadding from 'js/composable/authorablePadding';
import PartialLoader from 'js/components/UI/PartialLoader.vue';
import { pushProductImpression, pushProductClick } from 'js/common/analytics';
import {
    selectMarketingItem,
    addToMarketingCart,
    GA4ViewItemList,
    GA4SelectItem
} from 'js/common/analytics-ga4';
import { EventBus, EVENTS } from 'js/common/events';
import { useStore } from 'js/store';

export default defineComponent({
    name: 'horizontal-product-display',
    components: {
        MaxLengthText,
        PartialLoader
    },
    props: {
        initialProducts: {
            type: Array,
            default: () => []
        },
        hasPromotionalContent: {
            type: Boolean,
            default: false
        },
        promotionalContent: {
            type: Object,
            required: true
        },
        labels: {
            type: Object,
            required: true
        },
        listTagValue: {
            type: String,
            default: ''
        },
        pricingLazyLoad: {
            type: Boolean,
            default: false
        },
        showAddToCart: {
            type: Boolean,
            default: false
        },
        showReplacementItems: {
            type: Boolean,
            default: false
        },
        showLessThanFive: {
            type: Boolean,
            default: false
        },
        isAuthenticated: {
            type: Boolean,
            default: false
        },
        title: {
            type: String,
            default: ''
        },
        subtitle: {
            type: String,
            default: ''
        },
        widget: {
            type: String,
            default: ''
        },
        viewItemListId: {
            type: String,
            default: ''
        },
        viewItemListName: {
            type: String,
            default: ''
        },
        isAuthored: Boolean
    },
    setup(props) {
        const { paddingClass } = authorablePadding(props);
        const { replacePlaceholders, replaceTranslationPlaceholder } = translationsHelper();
        const scrollableContainer = ref(null);
        const blockContainer = ref(null);

        const pageCount = ref(1);
        const itemsPerPage = ref(5);
        const currentPage = ref(0);
        const minItemsLength = ref(5);
        const itemWidth = ref(222);
        const itemMargin = ref(7);
        const fetchError = ref('');
        const isLoadingPrice = ref(false);
        const isLoadingProducts = ref(false);
        const products = ref([...props.initialProducts]);
        const descriptionMaxLines = ref(2);
        const addToCartQueue = ref([]);
        const isAddingToCart = ref(false);

        const store = useStore();
        const instance = getCurrentInstance();
        const root = instance.proxy.$root;

        const isMarketingSite = computed(() => store.getters.isMarketingSite);
        const product = computed(() => store.getters.product);
        const showAlternatives = computed(() => store.getters.showAlternatives);
        const hasAlternativesForUnavailableItems = computed(() => store.getters.hasAlternativesForUnavailableItems);
        const showImperialValues = computed(() => store.getters.showImperialValues);

        const showComponent = computed(() => (products.value.length && (props.showLessThanFive || products.value.length >= minItemsLength.value)));
        const showAlternativeProducts = computed(() => {
            const alternativeWidgets = ['morsumProperty_PDP', 'alternativeProducts_PDP'];
            if (showAlternatives.value && hasAlternativesForUnavailableItems.value) {
                return showComponent.value && alternativeWidgets.includes(props.widget);
            }
            return false;
        });
        const showSimilarItems = computed(() => {
            if (!showAlternatives.value) {
                return showComponent.value && props.widget === 'lastWeekTrendingProducts_PDP';
            }
            return false;
        });

        const showRecentlyViewed = computed(() => showComponent.value && props.widget === 'recentlyViewedProducts_PDP');

        const showOtherRecommendedItems = computed(() => showComponent.value && Object.keys(product.value).length === 0);

        const pushViewItemListEvent = computed(
            () => (showAlternativeProducts.value || showSimilarItems.value || showRecentlyViewed.value || showOtherRecommendedItems.value)
        );
        const isLastPage = computed(() => (currentPage.value >= pageCount.value - 1));
        const showNavigation = computed(() => (pageCount.value > 1));
        const isShortProduct = computed(() => !props.isAuthenticated || !props.showAddToCart);

        const processItemFromQueue = () => {
            isAddingToCart.value = false;
            if (addToCartQueue.value.length > 0) {
                isAddingToCart.value = true;
                const itemFromQueue = addToCartQueue.value.shift();
                EventBus.$emit(EVENTS.CART.PRODUCT_PROCESS_ITEM_FROM_QUEUE, itemFromQueue);
            }
        };

        watch(addToCartQueue, () => {
            if (!isAddingToCart.value && addToCartQueue.value.length > 0) {
                processItemFromQueue();
            }
        });

        const translateCarousel = () => {
            const translateAmount = itemWidth.value * itemsPerPage.value + itemMargin.value * itemsPerPage.value;
            scrollableContainer.value.style.transform = `translateX(-${translateAmount * currentPage.value}px)`;
        };

        watch(() => root.$isDesktop, (newValue, oldValue) => {
            if (!products.value.length) {
                return;
            }

            currentPage.value = 0;
            translateCarousel();

            if (!oldValue && newValue) {
                blockContainer.value.scrollTo({ left: 0, behavior: 'smooth' });
            }
        });

        const addItemToCartQueue = addToCartRequest => {
            addToCartQueue.value.push(addToCartRequest);
        };

        EventBus.$on(EVENTS.CART.PRODUCT_ADDING_FROM_HORIZONTAL_DISPLAY, addItemToCartQueue());
        EventBus.$on(EVENTS.CART.PRODUCT_ADDED_TO_CART, processItemFromQueue);

        // const setElements = () => {
        //     scrollableContainer.value = this.$el.querySelector('.horizontal-product-display__container__scrollable-container');
        //     blockContainer.value = this.$el.querySelector('.horizontal-product-display__container');
        // };
        const setPagination = () => {
            const itemsCount = props.hasPromotionalContent ? products.value.length + 1 : products.value.length;

            itemsPerPage.value = Math.floor((scrollableContainer.value.clientWidth + itemMargin.value) / (itemWidth.value + itemMargin.value));
            pageCount.value = Math.ceil(itemsCount / itemsPerPage.value);
        };
        const handleResize = debounce(() => {
            // setElements();
            setPagination();
        }, 50);
        const setListeners = () => {
            window.addEventListener('resize', handleResize);
        };

        const mapGA4ItemArray = items => (
            items.map(item => ({
                item_name: item.Description,
                item_id: item.Code,
                affiliation: `${item.Gtin}_${item.Temperature}`,
                price: item.PriceFormatted,
                item_brand: item.Brand,
                item_category: item.CategoryLevel1,
                item_category2: item.CategoryLevel2,
                item_category3: item.CategoryLevel3,
                item_category4: item.Supplier,
                item_category5: showImperialValues.value ? item.ImperialCaseShipingWeight : item.MetricCaseShippingWeight,
                item_variant: item.Flavor,
                item_list_name: props.viewItemListName,
                item_list_id: props.viewItemListId,
                quantity: item.AddToCartViewModel.MinQuantity
            }))
        );

        const fetchPricing = async productsParam => {
            const codes = productsParam.map(productMap => productMap.Code);
            isLoadingPrice.value = true;
            const res = await getPrices({ Item: codes });
            if (res.error) {
                console.log(res.error.response); // eslint-disable-line no-console
            } else {
                products.value = prices(productsParam, res.data);
                nextTick(() => {
                    setPagination();
                    setListeners();
                    if (!isMarketingSite.value) {
                        pushProductImpression(products.value, props.listTagValue);
                        if (pushViewItemListEvent.value) {
                            GA4ViewItemList(mapGA4ItemArray(products.value));
                        }
                    }
                });
            }
            isLoadingPrice.value = false;
        };

        const bootstrapData = () => {
            // setElements();

            if (props.isAuthenticated && props.pricingLazyLoad && products.value.length) {
                fetchPricing(products.value);
            } else {
                if (!isMarketingSite.value) {
                    pushProductImpression(products.value, props.listTagValue);
                    GA4ViewItemList(mapGA4ItemArray(products.value));
                }
                nextTick(() => {
                    setPagination();
                    setListeners();
                });
            }
        };

        const getRecommendationsMethod = event => {
            if (!event.detail || props.isAuthored) {
                return;
            }
            const { smartRecs } = event.detail;
            // the epi response has all the instances in the page, we need to filter this instance
            const instanceRecs = smartRecs.find(x => x.widget === props.widget) || {};

            if (Object.keys(instanceRecs).length) {
                isLoadingProducts.value = true;
                const res = getRecommendations({ smartRecs: instanceRecs.recs, widget: props.widget, itemCode: product.value.Code });
                if (res.error) {
                    console.log(res.error.response); // eslint-disable-line no-console
                } else {
                    products.value = res.data.RecommendedItems;
                    isLoadingProducts.value = false;
                    bootstrapData();
                }
            }
        };

        const getAsyncMorsumRecommendations = async () => {
            const res = await getRecommendations({ smartRecs: null, widget: props.widget, itemCode: product.value.Code });
            if (res.error) {
                console.log(res.error.response); // eslint-disable-line no-console
            } else {
                products.value = res.data.RecommendedItems;
                isLoadingProducts.value = false;
                bootstrapData();
            }
        };

        /**
        * Call fetchData function before the component render.
        */
        onMounted(() => {
            if (props.widget === 'morsumProperty_PDP' && showAlternatives.value) {
                getAsyncMorsumRecommendations();
            } else if (props.widget === 'lastWeekTrendingProducts_PDP' && !showAlternatives.value) {
                window.addEventListener('epi-recommendations', getRecommendationsMethod.bind(this));
            } else if (props.widget === 'recentlyViewedProducts_PDP') {
                window.addEventListener('epi-recommendations', getRecommendationsMethod.bind(this));
            }
            if (!products.value.length) return;
            bootstrapData();
        });

        onBeforeUnmount(() => {
            window.removeEventListener('resize', handleResize);
            window.removeEventListener('epi-recommendations', getRecommendationsMethod.bind(this));
            EventBus.$off(EVENTS.CART.PRODUCT_ADDING_FROM_HORIZONTAL_DISPLAY, addItemToCartQueue());
            EventBus.$off(EVENTS.CART.PRODUCT_ADDED_TO_CART, processItemFromQueue);
        });

        const pushToDataLayer = (productParam, index, obj) => {
            const item = {
                item_id: productParam.Code,
                item_name: productParam.Description,
                currency: productParam.Price.Currency.CurrencyCode,
                index,
                item_category: productParam.Category,
                item_category2: '',
                item_category3: productParam.IsPackageProduct ? 'Package Product' : 'Individual Product',
                price: productParam.Price.Amount,
                quantity: obj.quantity
            };
            addToMarketingCart(item);
        };

        const updateInventoryMessage = obj => {
            const index = products.value.findIndex(object => object.Code === obj.code);
            products.value[index].StockStatus = obj.message;
        };

        const navigatePrevious = () => {
            if (currentPage.value !== 0) {
                currentPage.value -= 1;
                translateCarousel();
            }
        };
        const navigateNext = () => {
            if (currentPage.value < pageCount.value - 1) {
                currentPage.value += 1;
                translateCarousel();
            }
        };
        const ga4ItemObj = item => ({
            item_name: item.Description,
            item_id: item.Code,
            affiliation: `${item.Gtin}_${item.Temperature}`,
            price: item.PriceFormatted,
            item_brand: item.Brand,
            item_category: item.CategoryLevel1,
            item_category2: item.CategoryLevel2,
            item_category3: item.CategoryLevel3,
            item_category4: item.Supplier,
            item_category5: showImperialValues.value ? item.ImperialCaseShipingWeight : item.MetricCaseShippingWeight,
            item_variant: item.Flavor,
            item_list_name: props.viewItemListName,
            item_list_id: props.viewItemListId
        });
        const goToProductDetails = (event, productParam, index) => {
            const openInNewWindow = event.ctrlKey || event.metaKey || productParam.OpenInNewWindow;
            if (!isMarketingSite.value) {
                GA4SelectItem({ ...ga4ItemObj(productParam), index: index + 1, quantity: 1 });
                pushProductClick(productParam, index, props.listTagValue, openInNewWindow);
            } else {
                selectMarketingItem(productParam, index, props.title, props.widget, openInNewWindow);
            }
        };
        return {
            pageCount,
            itemsPerPage,
            currentPage,
            minItemsLength,
            itemWidth,
            itemMargin,
            fetchError,
            isLoadingPrice,
            isLoadingProducts,
            products,
            descriptionMaxLines,
            addToCartQueue,
            isAddingToCart,
            isMarketingSite,
            product,
            showAlternatives,
            showAlternativeProducts,
            showSimilarItems,
            showRecentlyViewed,
            showOtherRecommendedItems,
            pushViewItemListEvent,
            isLastPage,
            showNavigation,
            isShortProduct,
            processItemFromQueue,
            translateCarousel,
            addItemToCartQueue,
            setPagination,
            handleResize,
            setListeners,
            mapGA4ItemArray,
            fetchPricing,
            bootstrapData,
            getRecommendationsMethod,
            getRecommendations,
            getAsyncMorsumRecommendations,
            pushToDataLayer,
            updateInventoryMessage,
            navigatePrevious,
            navigateNext,
            goToProductDetails,
            ga4ItemObj,
            scrollableContainer,
            paddingClass,
            replacePlaceholders,
            replaceTranslationPlaceholder,
            blockContainer
        };
    }
});
</script>